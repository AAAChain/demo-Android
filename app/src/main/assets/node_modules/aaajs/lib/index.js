'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ecc = require('eosjs-ecc');
var Fcbuffer = require('fcbuffer');
var EosApi = require('eosjs-api');
var assert = require('assert');

var Structs = require('./structs');
var AbiCache = require('./abi-cache');
var writeApiGen = require('./write-api');
var format = require('./format');
var schema = require('./schema');

var token = require('./schema/eosio.token.abi.json');
var system = require('./schema/eosio.system.abi.json');
var eosio_null = require('./schema/eosio.null.abi.json');

var Eos = function Eos() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var configDefaults = {
    httpEndpoint: 'http://127.0.0.1:8888',
    paymentUser: 'aaatrust1111',
    debug: false,
    verbose: false,
    broadcast: true,
    logger: {
      log: function log() {
        var _console;

        return config.verbose ? (_console = console).log.apply(_console, arguments) : null;
      },
      error: function error() {
        var _console2;

        return config.verbose ? (_console2 = console).error.apply(_console2, arguments) : null;
      }
    },
    sign: true
  };

  function applyDefaults(target, defaults) {
    Object.keys(defaults).forEach(function (key) {
      if (target[key] === undefined) {
        target[key] = defaults[key];
      }
    });
  }

  applyDefaults(config, configDefaults);
  applyDefaults(config.logger, configDefaults.logger);
  return createEos(config);
};

module.exports = Eos;

Object.assign(Eos, {
  version: '16.0.0',
  modules: {
    format: format,
    api: EosApi,
    ecc: ecc,
    json: {
      api: EosApi.api,
      schema: schema
    },
    Fcbuffer: Fcbuffer
  },

  /** @deprecated */
  Testnet: function Testnet(config) {
    console.error('deprecated, change Eos.Testnet(..) to just Eos(..)');
    return Eos(config);
  },

  /** @deprecated */
  Localnet: function Localnet(config) {
    console.error('deprecated, change Eos.Localnet(..) to just Eos(..)');
    return Eos(config);
  }
});

// 这个函数的功能：授权合约从买家帐号扣款。
//
// 参数说明：
// buyer: 买家账号
//
// 注：
// 1. 调用函数payForGood前，必须先进行授权。
// 2. 授权信息记录在链上，对于同一个买家来说，这个函数只需要调用一次。
function authPermisson(buyer) {
  var accountInfo, activeAuth, needAddPermission, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, perm, accounts, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, account, op_data;

  return _regenerator2.default.async(function authPermisson$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return _regenerator2.default.awrap(this.getAccount(buyer));

        case 2:
          accountInfo = _context.sent;
          activeAuth = {};
          needAddPermission = true;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 8;
          _iterator = accountInfo.permissions[Symbol.iterator]();

        case 10:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 46;
            break;
          }

          perm = _step.value;

          if (!(perm.perm_name === "active")) {
            _context.next = 43;
            break;
          }

          activeAuth = perm.required_auth;
          accounts = activeAuth.accounts;
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 18;
          _iterator2 = accounts[Symbol.iterator]();

        case 20:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 28;
            break;
          }

          account = _step2.value;

          if (!(account.permission.actor === this.config.paymentUser && account.permission.permission === "eosio.code")) {
            _context.next = 25;
            break;
          }

          // already add this permission, don't need add it again.
          needAddPermission = false;
          throw "the permission already existing, do nothing.";

        case 25:
          _iteratorNormalCompletion2 = true;
          _context.next = 20;
          break;

        case 28:
          _context.next = 34;
          break;

        case 30:
          _context.prev = 30;
          _context.t0 = _context['catch'](18);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t0;

        case 34:
          _context.prev = 34;
          _context.prev = 35;

          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }

        case 37:
          _context.prev = 37;

          if (!_didIteratorError2) {
            _context.next = 40;
            break;
          }

          throw _iteratorError2;

        case 40:
          return _context.finish(37);

        case 41:
          return _context.finish(34);

        case 42:

          if (needAddPermission === true) {
            accounts.push({ permission: { actor: this.config.paymentUser,
                permission: "eosio.code" },
              weight: 1 });
          }

        case 43:
          _iteratorNormalCompletion = true;
          _context.next = 10;
          break;

        case 46:
          _context.next = 52;
          break;

        case 48:
          _context.prev = 48;
          _context.t1 = _context['catch'](8);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 52:
          _context.prev = 52;
          _context.prev = 53;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 55:
          _context.prev = 55;

          if (!_didIteratorError) {
            _context.next = 58;
            break;
          }

          throw _iteratorError;

        case 58:
          return _context.finish(55);

        case 59:
          return _context.finish(52);

        case 60:
          op_data = {
            account: buyer,
            permission: 'active',
            parent: 'owner',
            auth: activeAuth
          };
          return _context.abrupt('return', this.updateauth(op_data));

        case 62:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this, [[8, 48, 52, 60], [18, 30, 34, 42], [35,, 37, 41], [53,, 55, 59]]);
}

// 这个函数的功能为：买家预付款。
//
// 参数说明：
// id: 用于唯一标识这笔预付款，它的类型必须为uint64，且不能重复
// buyer: 买家账号，必须是链上存在的用户
// seller: 卖家账号，必须是链上存在的用户
// price: 商品价格，比如 "3.0000 EOS"
//
// 注：
// 1. 它不会直接打钱给卖家，而是暂时打款到中间帐号，当买家确定收到商品后，
// 应该调用 confirmPayment 来确认付款。
// 2. 调用本函数前，请确保已授权合约从buyer扣款；如果没有，请调用authPermisson
function payForGood(id, buyer, seller, price) {
  var options, contract;
  return _regenerator2.default.async(function payForGood$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = { authorization: [buyer + '@active'] };
          _context2.next = 3;
          return _regenerator2.default.awrap(this.contract(this.config.paymentUser));

        case 3:
          contract = _context2.sent;
          return _context2.abrupt('return', contract.prepay(id, buyer, seller, price, options));

        case 5:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
}

// 这个函数的功能为：买家确认付款，预付款时的钱将打到卖家帐号。
//
// 参数说明：
// id: 预付款id
function confirmPayment(buyer, id) {
  var options, contract;
  return _regenerator2.default.async(function confirmPayment$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          options = { authorization: [buyer + '@active'] };
          _context3.next = 3;
          return _regenerator2.default.awrap(this.contract(this.config.paymentUser));

        case 3:
          contract = _context3.sent;
          return _context3.abrupt('return', contract.confirm(id, options));

        case 5:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
}

function createEos(config) {
  var network = config.httpEndpoint != null ? EosApi(config) : null;
  config.network = network;

  var abis = [];
  var abiCache = AbiCache(network, config);
  abis.push(abiCache.abi('eosio.null', eosio_null));
  abis.push(abiCache.abi('eosio.token', token));
  abis.push(abiCache.abi('eosio', system));

  if (!config.chainId) {
    config.chainId = 'cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f';
  }

  if (network) {
    checkChainId(network, config.chainId, config.logger);
  }

  if (config.mockTransactions != null) {
    if (typeof config.mockTransactions === 'string') {
      var mock = config.mockTransactions;
      config.mockTransactions = function () {
        return mock;
      };
    }
    assert.equal((0, _typeof3.default)(config.mockTransactions), 'function', 'config.mockTransactions');
  }

  var _Structs = Structs(config),
      structs = _Structs.structs,
      types = _Structs.types,
      fromBuffer = _Structs.fromBuffer,
      toBuffer = _Structs.toBuffer;

  var eos = mergeWriteFunctions(config, EosApi, structs, abis);

  Object.assign(eos, {
    config: safeConfig(config),
    fc: {
      structs: structs,
      types: types,
      fromBuffer: fromBuffer,
      toBuffer: toBuffer,
      abiCache: abiCache
    },
    authPermisson: authPermisson,
    payForGood: payForGood,
    confirmPayment: confirmPayment,
    // Repeat of static Eos.modules, help apps that use dependency injection
    modules: {
      format: format
    }
  });

  if (!config.signProvider) {
    config.signProvider = defaultSignProvider(eos, config);
  }

  return eos;
}

/**
  Set each property as read-only, read-write, no-access.  This is shallow
  in that it applies only to the root object and does not limit access
  to properties under a given object.
*/
function safeConfig(config) {
  // access control is shallow references only
  var readOnly = new Set(['httpEndpoint', 'abiCache', 'chainId', 'expireInSeconds', 'paymentUser']);
  var readWrite = new Set(['verbose', 'debug', 'broadcast', 'logger', 'sign']);
  var protectedConfig = {};

  Object.keys(config).forEach(function (key) {
    Object.defineProperty(protectedConfig, key, {
      set: function set(value) {
        if (readWrite.has(key)) {
          config[key] = value;
          return;
        }
        throw new Error('Access denied');
      },

      get: function get() {
        if (readOnly.has(key) || readWrite.has(key)) {
          return config[key];
        }
        throw new Error('Access denied');
      }
    });
  });
  return protectedConfig;
}

/**
  Merge in write functions (operations).  Tested against existing methods for
  name conflicts.

  @arg {object} config.network - read-only api calls
  @arg {object} EosApi - api[EosApi] read-only api calls
  @return {object} - read and write method calls (create and sign transactions)
  @throw {TypeError} if a funciton name conflicts
*/
function mergeWriteFunctions(config, EosApi, structs, abis) {
  var network = config.network;


  var merge = Object.assign({}, network);

  var writeApi = writeApiGen(EosApi, network, structs, config, abis);
  throwOnDuplicate(merge, writeApi, 'Conflicting methods in EosApi and Transaction Api');
  Object.assign(merge, writeApi);

  return merge;
}

function throwOnDuplicate(o1, o2, msg) {
  for (var key in o1) {
    if (o2[key]) {
      throw new TypeError(msg + ': ' + key);
    }
  }
}

/**
  The default sign provider is designed to interact with the available public
  keys (maybe just one), the transaction, and the blockchain to figure out
  the minimum set of signing keys.

  If only one key is available, the blockchain API calls are skipped and that
  key is used to sign the transaction.
*/
var defaultSignProvider = function defaultSignProvider(eos, config) {
  return function _callee(_ref) {
    var sign = _ref.sign,
        buf = _ref.buf,
        transaction = _ref.transaction,
        optionsKeyProvider = _ref.optionsKeyProvider;

    var keyProvider, keys, pvt, sigs, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, key, keyMap, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _key, isPrivate, isPublic, pubkeys;

    return _regenerator2.default.async(function _callee$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            // optionsKeyProvider is a per-action key: await eos.someAction('user2' .., {keyProvider: privateKey2})
            keyProvider = optionsKeyProvider ? optionsKeyProvider : config.keyProvider;

            if (keyProvider) {
              _context4.next = 3;
              break;
            }

            throw new TypeError('This transaction requires a keyProvider for signing');

          case 3:
            keys = keyProvider;

            if (typeof keyProvider === 'function') {
              keys = keyProvider({ transaction: transaction });
            }

            // keyProvider may return keys or Promise<keys>
            _context4.next = 7;
            return _regenerator2.default.awrap(Promise.resolve(keys));

          case 7:
            keys = _context4.sent;


            if (!Array.isArray(keys)) {
              keys = [keys];
            }

            keys = keys.map(function (key) {
              try {
                // normalize format (WIF => PVT_K1_base58privateKey)
                return { private: ecc.PrivateKey(key).toString() };
              } catch (e) {
                // normalize format (EOSKey => PUB_K1_base58publicKey)
                return { public: ecc.PublicKey(key).toString() };
              }
              assert(false, 'expecting public or private keys from keyProvider');
            });

            if (keys.length) {
              _context4.next = 12;
              break;
            }

            throw new Error('missing key, check your keyProvider');

          case 12:
            if (!(keys.length === 1 && keys[0].private)) {
              _context4.next = 15;
              break;
            }

            pvt = keys[0].private;
            return _context4.abrupt('return', sign(buf, pvt));

          case 15:
            if (!(config.httpEndpoint == null)) {
              _context4.next = 37;
              break;
            }

            sigs = [];
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _iteratorError3 = undefined;
            _context4.prev = 20;

            for (_iterator3 = keys[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              key = _step3.value;

              sigs.push(sign(buf, key.private));
            }
            _context4.next = 28;
            break;

          case 24:
            _context4.prev = 24;
            _context4.t0 = _context4['catch'](20);
            _didIteratorError3 = true;
            _iteratorError3 = _context4.t0;

          case 28:
            _context4.prev = 28;
            _context4.prev = 29;

            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError3) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError3;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(28);

          case 36:
            return _context4.abrupt('return', sigs);

          case 37:
            keyMap = new Map();

            // keys are either public or private keys

            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _iteratorError4 = undefined;
            _context4.prev = 41;
            for (_iterator4 = keys[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              _key = _step4.value;
              isPrivate = _key.private != null;
              isPublic = _key.public != null;


              if (isPrivate) {
                keyMap.set(ecc.privateToPublic(_key.private), _key.private);
              } else {
                keyMap.set(_key.public, null);
              }
            }

            _context4.next = 49;
            break;

          case 45:
            _context4.prev = 45;
            _context4.t1 = _context4['catch'](41);
            _didIteratorError4 = true;
            _iteratorError4 = _context4.t1;

          case 49:
            _context4.prev = 49;
            _context4.prev = 50;

            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }

          case 52:
            _context4.prev = 52;

            if (!_didIteratorError4) {
              _context4.next = 55;
              break;
            }

            throw _iteratorError4;

          case 55:
            return _context4.finish(52);

          case 56:
            return _context4.finish(49);

          case 57:
            pubkeys = Array.from(keyMap.keys());
            return _context4.abrupt('return', eos.getRequiredKeys(transaction, pubkeys).then(function (_ref2) {
              var required_keys = _ref2.required_keys;

              if (!required_keys.length) {
                throw new Error('missing required keys for ' + JSON.stringify(transaction));
              }

              var pvts = [],
                  missingKeys = [];

              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = required_keys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var requiredKey = _step5.value;

                  // normalize (EOSKey.. => PUB_K1_Key..)
                  requiredKey = ecc.PublicKey(requiredKey).toString();

                  var wif = keyMap.get(requiredKey);
                  if (wif) {
                    pvts.push(wif);
                  } else {
                    missingKeys.push(requiredKey);
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              if (missingKeys.length !== 0) {
                assert(typeof keyProvider === 'function', 'keyProvider function is needed for private key lookup');

                // const pubkeys = missingKeys.map(key => ecc.PublicKey(key).toStringLegacy())
                keyProvider({ pubkeys: missingKeys }).forEach(function (pvt) {
                  pvts.push(pvt);
                });
              }

              var sigs = [];
              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = pvts[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _pvt = _step6.value;

                  sigs.push(sign(buf, _pvt));
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }

              return sigs;
            }));

          case 59:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, this, [[20, 24, 28, 36], [29,, 31, 35], [41, 45, 49, 57], [50,, 52, 56]]);
  };
};

function checkChainId(network, chainId, logger) {
  network.getInfo({}).then(function (info) {
    if (info.chain_id !== chainId) {
      if (logger.log) {
        logger.log('chainId mismatch, signatures will not match transaction authority. ' + ('expected ' + chainId + ' !== actual ' + info.chain_id));
      }
    }
  }).catch(function (error) {
    if (logger.error) {
      logger.error('Warning, unable to validate chainId: ' + error.message);
    }
  });
}